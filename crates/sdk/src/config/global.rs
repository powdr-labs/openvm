use bon::Builder;
use openvm_algebra_circuit::{
    AlgebraCpuProverExt, Fp2Extension, Fp2ExtensionExecutor, ModularExtension,
    ModularExtensionExecutor,
};
use openvm_algebra_transpiler::{Fp2TranspilerExtension, ModularTranspilerExtension};
use openvm_bigint_circuit::{Int256, Int256CpuProverExt, Int256Executor};
use openvm_bigint_transpiler::Int256TranspilerExtension;
use openvm_circuit::{
    arch::{
        instructions::NATIVE_AS, AirInventory, AirInventoryError, ChipInventoryError,
        ExecutorInventory, ExecutorInventoryError, InitFileGenerator, MatrixRecordArena,
        SystemConfig, VmBuilder, VmChipComplex, VmCircuitConfig, VmExecutionConfig,
        VmProverExtension,
    },
    derive::VmConfig,
    system::{SystemChipInventory, SystemCpuBuilder, SystemExecutor},
};
use openvm_ecc_circuit::{EccCpuProverExt, WeierstrassExtension, WeierstrassExtensionExecutor};
use openvm_ecc_transpiler::EccTranspilerExtension;
use openvm_keccak256_circuit::{Keccak256, Keccak256CpuProverExt, Keccak256Executor};
use openvm_keccak256_transpiler::Keccak256TranspilerExtension;
use openvm_native_circuit::{
    CastFExtension, CastFExtensionExecutor, Native, NativeCpuProverExt, NativeExecutor,
};
use openvm_native_transpiler::LongFormTranspilerExtension;
use openvm_pairing_circuit::{PairingCpuProverExt, PairingExtension, PairingExtensionExecutor};
use openvm_pairing_transpiler::PairingTranspilerExtension;
use openvm_rv32im_circuit::{
    Rv32I, Rv32IExecutor, Rv32ImCpuProverExt, Rv32Io, Rv32IoExecutor, Rv32M, Rv32MExecutor,
};
use openvm_rv32im_transpiler::{
    Rv32ITranspilerExtension, Rv32IoTranspilerExtension, Rv32MTranspilerExtension,
};
use openvm_sha256_circuit::{Sha256, Sha256Executor, Sha2CpuProverExt};
use openvm_sha256_transpiler::Sha256TranspilerExtension;
use openvm_stark_backend::{
    config::{StarkGenericConfig, Val},
    engine::StarkEngine,
    p3_field::{Field, PrimeField32},
    prover::cpu::{CpuBackend, CpuDevice},
};
use openvm_transpiler::transpiler::Transpiler;
use serde::{Deserialize, Serialize};

use crate::F;

#[derive(Builder, Clone, Debug, Serialize, Deserialize)]
#[serde(from = "SdkVmConfigWithDefaultDeser")]
pub struct SdkVmConfig {
    pub system: SdkSystemConfig,
    pub rv32i: Option<UnitStruct>,
    pub io: Option<UnitStruct>,
    pub keccak: Option<UnitStruct>,
    pub sha256: Option<UnitStruct>,
    pub native: Option<UnitStruct>,
    pub castf: Option<UnitStruct>,

    pub rv32m: Option<Rv32M>,
    pub bigint: Option<Int256>,
    pub modular: Option<ModularExtension>,
    pub fp2: Option<Fp2Extension>,
    pub pairing: Option<PairingExtension>,
    pub ecc: Option<WeierstrassExtension>,
}

#[derive(Copy, Clone)]
pub struct SdkVmCpuBuilder;

/// Internal struct to use for the VmConfig derive macro.
/// Can be obtained via [`SdkVmConfig::to_inner`].
#[derive(Clone, Debug, VmConfig, Serialize, Deserialize)]
pub struct SdkVmConfigInner {
    #[config(executor = "SystemExecutor<F>")]
    pub system: SystemConfig,
    #[extension(executor = "Rv32IExecutor")]
    pub rv32i: Option<Rv32I>,
    #[extension(executor = "Rv32IoExecutor")]
    pub io: Option<Rv32Io>,
    #[extension(executor = "Keccak256Executor")]
    pub keccak: Option<Keccak256>,
    #[extension(executor = "Sha256Executor")]
    pub sha256: Option<Sha256>,
    #[extension(executor = "NativeExecutor<F>")]
    pub native: Option<Native>,
    #[extension(executor = "CastFExtensionExecutor")]
    pub castf: Option<CastFExtension>,

    #[extension(executor = "Rv32MExecutor")]
    pub rv32m: Option<Rv32M>,
    #[extension(executor = "Int256Executor")]
    pub bigint: Option<Int256>,
    #[extension(executor = "ModularExtensionExecutor")]
    pub modular: Option<ModularExtension>,
    #[extension(executor = "Fp2ExtensionExecutor")]
    pub fp2: Option<Fp2Extension>,
    #[extension(executor = "PairingExtensionExecutor<F>")]
    pub pairing: Option<PairingExtension>,
    #[extension(executor = "WeierstrassExtensionExecutor")]
    pub ecc: Option<WeierstrassExtension>,
}

// Generated by macro
pub type SdkVmConfigExecutor<F> = SdkVmConfigInnerExecutor<F>;

impl SdkVmConfig {
    pub fn transpiler(&self) -> Transpiler<F> {
        let mut transpiler = Transpiler::default();
        if self.rv32i.is_some() {
            transpiler = transpiler.with_extension(Rv32ITranspilerExtension);
        }
        if self.io.is_some() {
            transpiler = transpiler.with_extension(Rv32IoTranspilerExtension);
        }
        if self.keccak.is_some() {
            transpiler = transpiler.with_extension(Keccak256TranspilerExtension);
        }
        if self.sha256.is_some() {
            transpiler = transpiler.with_extension(Sha256TranspilerExtension);
        }
        if self.native.is_some() {
            transpiler = transpiler.with_extension(LongFormTranspilerExtension);
        }
        if self.rv32m.is_some() {
            transpiler = transpiler.with_extension(Rv32MTranspilerExtension);
        }
        if self.bigint.is_some() {
            transpiler = transpiler.with_extension(Int256TranspilerExtension);
        }
        if self.modular.is_some() {
            transpiler = transpiler.with_extension(ModularTranspilerExtension);
        }
        if self.fp2.is_some() {
            transpiler = transpiler.with_extension(Fp2TranspilerExtension);
        }
        if self.pairing.is_some() {
            transpiler = transpiler.with_extension(PairingTranspilerExtension);
        }
        if self.ecc.is_some() {
            transpiler = transpiler.with_extension(EccTranspilerExtension);
        }
        transpiler
    }
}

impl AsRef<SystemConfig> for SdkVmConfig {
    fn as_ref(&self) -> &SystemConfig {
        &self.system.config
    }
}

impl AsMut<SystemConfig> for SdkVmConfig {
    fn as_mut(&mut self) -> &mut SystemConfig {
        &mut self.system.config
    }
}

impl SdkVmConfig {
    fn to_inner(&self) -> SdkVmConfigInner {
        let system = self.system.config.clone();
        let rv32i = self.rv32i.map(|_| Rv32I);
        let io = self.io.map(|_| Rv32Io);
        let keccak = self.keccak.map(|_| Keccak256);
        let sha256 = self.sha256.map(|_| Sha256);
        let native = self.native.map(|_| Native);
        let castf = self.castf.map(|_| CastFExtension);
        let mut rv32m = self.rv32m;
        let mut bigint = self.bigint;
        if let Some(bigint) = &mut bigint {
            if let Some(rv32m) = &mut rv32m {
                rv32m.range_tuple_checker_sizes[0] =
                    rv32m.range_tuple_checker_sizes[0].max(bigint.range_tuple_checker_sizes[0]);
                rv32m.range_tuple_checker_sizes[1] =
                    rv32m.range_tuple_checker_sizes[1].max(bigint.range_tuple_checker_sizes[1]);
                bigint.range_tuple_checker_sizes = rv32m.range_tuple_checker_sizes;
            }
        }
        let modular = self.modular.clone();
        let fp2 = self.fp2.clone();
        let pairing = self.pairing.clone();
        let ecc = self.ecc.clone();

        SdkVmConfigInner {
            system,
            rv32i,
            io,
            keccak,
            sha256,
            native,
            castf,
            rv32m,
            bigint,
            modular,
            fp2,
            pairing,
            ecc,
        }
    }
}

impl<F: Field> VmExecutionConfig<F> for SdkVmConfig
where
    SdkVmConfigInner: VmExecutionConfig<F>,
{
    type Executor = <SdkVmConfigInner as VmExecutionConfig<F>>::Executor;

    fn create_executors(
        &self,
    ) -> Result<ExecutorInventory<Self::Executor>, ExecutorInventoryError> {
        self.to_inner().create_executors()
    }
}

impl<SC: StarkGenericConfig> VmCircuitConfig<SC> for SdkVmConfig
where
    SdkVmConfigInner: VmCircuitConfig<SC>,
{
    fn create_airs(&self) -> Result<AirInventory<SC>, AirInventoryError> {
        self.to_inner().create_airs()
    }
}

impl<E, SC> VmBuilder<E> for SdkVmCpuBuilder
where
    SC: StarkGenericConfig,
    E: StarkEngine<SC = SC, PB = CpuBackend<SC>, PD = CpuDevice<SC>>,
    Val<SC>: PrimeField32,
{
    type VmConfig = SdkVmConfig;
    type SystemChipInventory = SystemChipInventory<SC>;
    type RecordArena = MatrixRecordArena<Val<SC>>;

    fn create_chip_complex(
        &self,
        config: &SdkVmConfig,
        circuit: AirInventory<SC>,
    ) -> Result<
        VmChipComplex<SC, Self::RecordArena, E::PB, Self::SystemChipInventory>,
        ChipInventoryError,
    > {
        let config = config.to_inner();
        let mut chip_complex =
            VmBuilder::<E>::create_chip_complex(&SystemCpuBuilder, &config.system, circuit)?;
        let inventory = &mut chip_complex.inventory;
        if let Some(rv32i) = &config.rv32i {
            VmProverExtension::<E, _, _>::extend_prover(&Rv32ImCpuProverExt, rv32i, inventory)?;
        }
        if let Some(io) = &config.io {
            VmProverExtension::<E, _, _>::extend_prover(&Rv32ImCpuProverExt, io, inventory)?;
        }
        if let Some(keccak) = &config.keccak {
            VmProverExtension::<E, _, _>::extend_prover(&Keccak256CpuProverExt, keccak, inventory)?;
        }
        if let Some(sha256) = &config.sha256 {
            VmProverExtension::<E, _, _>::extend_prover(&Sha2CpuProverExt, sha256, inventory)?;
        }
        if let Some(native) = &config.native {
            VmProverExtension::<E, _, _>::extend_prover(&NativeCpuProverExt, native, inventory)?;
        }
        if let Some(castf) = &config.castf {
            VmProverExtension::<E, _, _>::extend_prover(&NativeCpuProverExt, castf, inventory)?;
        }

        if let Some(rv32m) = &config.rv32m {
            VmProverExtension::<E, _, _>::extend_prover(&Rv32ImCpuProverExt, rv32m, inventory)?;
        }
        if let Some(bigint) = &config.bigint {
            VmProverExtension::<E, _, _>::extend_prover(&Int256CpuProverExt, bigint, inventory)?;
        }
        if let Some(modular) = &config.modular {
            VmProverExtension::<E, _, _>::extend_prover(&AlgebraCpuProverExt, modular, inventory)?;
        }
        if let Some(fp2) = &config.fp2 {
            VmProverExtension::<E, _, _>::extend_prover(&AlgebraCpuProverExt, fp2, inventory)?;
        }
        if let Some(pairing) = &config.pairing {
            VmProverExtension::<E, _, _>::extend_prover(&PairingCpuProverExt, pairing, inventory)?;
        }
        if let Some(ecc) = &config.ecc {
            VmProverExtension::<E, _, _>::extend_prover(&EccCpuProverExt, ecc, inventory)?;
        }
        Ok(chip_complex)
    }
}

impl InitFileGenerator for SdkVmConfig {
    fn generate_init_file_contents(&self) -> Option<String> {
        self.to_inner().generate_init_file_contents()
    }
}
impl InitFileGenerator for SdkVmConfigInner {
    fn generate_init_file_contents(&self) -> Option<String> {
        if self.modular.is_some() || self.fp2.is_some() || self.ecc.is_some() {
            let mut contents = String::new();
            contents.push_str(
                "// This file is automatically generated by cargo openvm. Do not rename or edit.\n",
            );

            if let Some(modular_config) = &self.modular {
                contents.push_str(&modular_config.generate_moduli_init());
                contents.push('\n');
            }

            if let Some(fp2_config) = &self.fp2 {
                assert!(
                    self.modular.is_some(),
                    "ModularExtension is required for Fp2Extension"
                );
                let modular_config = self.modular.as_ref().unwrap();
                contents.push_str(&fp2_config.generate_complex_init(modular_config));
                contents.push('\n');
            }

            if let Some(ecc_config) = &self.ecc {
                contents.push_str(&ecc_config.generate_sw_init());
                contents.push('\n');
            }

            Some(contents)
        } else {
            None
        }
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct SdkSystemConfig {
    pub config: SystemConfig,
}

// Default implementation uses no init file
impl InitFileGenerator for SdkSystemConfig {}

impl Default for SdkSystemConfig {
    fn default() -> Self {
        Self {
            config: SystemConfig::default().with_continuations(),
        }
    }
}

impl From<SystemConfig> for SdkSystemConfig {
    fn from(config: SystemConfig) -> Self {
        Self { config }
    }
}

/// A struct that is used to represent a unit struct in the config, used for
/// serialization and deserialization.
#[derive(Clone, Copy, Debug, Default, Serialize, Deserialize)]
pub struct UnitStruct {}

impl From<Rv32I> for UnitStruct {
    fn from(_: Rv32I) -> Self {
        UnitStruct {}
    }
}

impl From<Rv32Io> for UnitStruct {
    fn from(_: Rv32Io) -> Self {
        UnitStruct {}
    }
}

impl From<Keccak256> for UnitStruct {
    fn from(_: Keccak256) -> Self {
        UnitStruct {}
    }
}

impl From<Sha256> for UnitStruct {
    fn from(_: Sha256) -> Self {
        UnitStruct {}
    }
}

impl From<Native> for UnitStruct {
    fn from(_: Native) -> Self {
        UnitStruct {}
    }
}

impl From<CastFExtension> for UnitStruct {
    fn from(_: CastFExtension) -> Self {
        UnitStruct {}
    }
}

#[derive(Deserialize)]
struct SdkVmConfigWithDefaultDeser {
    #[serde(default)]
    pub system: SdkSystemConfig,

    pub rv32i: Option<UnitStruct>,
    pub io: Option<UnitStruct>,
    pub keccak: Option<UnitStruct>,
    pub sha256: Option<UnitStruct>,
    pub native: Option<UnitStruct>,
    pub castf: Option<UnitStruct>,

    pub rv32m: Option<Rv32M>,
    pub bigint: Option<Int256>,
    pub modular: Option<ModularExtension>,
    pub fp2: Option<Fp2Extension>,
    pub pairing: Option<PairingExtension>,
    pub ecc: Option<WeierstrassExtension>,
}

impl From<SdkVmConfigWithDefaultDeser> for SdkVmConfig {
    fn from(config: SdkVmConfigWithDefaultDeser) -> Self {
        let mut system = config.system;
        if config.native.is_none() && config.castf.is_none() {
            // There should be no need to write to native address space if Native extension and
            // CastF extension are not enabled.
            system.config.memory_config.addr_space_sizes[NATIVE_AS as usize] = 0;
        }
        Self {
            system,
            rv32i: config.rv32i,
            io: config.io,
            keccak: config.keccak,
            sha256: config.sha256,
            native: config.native,
            castf: config.castf,
            rv32m: config.rv32m,
            bigint: config.bigint,
            modular: config.modular,
            fp2: config.fp2,
            pairing: config.pairing,
            ecc: config.ecc,
        }
    }
}
