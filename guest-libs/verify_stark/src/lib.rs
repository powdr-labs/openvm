#[cfg(not(target_os = "zkvm"))]
pub mod host;

/// Define a function that verifies an OpenVM Stark proof.
/// To define this function, users need to specify the function name and an ASM file containing the
/// assembly code for the verification(this ASM file can be generated by
/// `Sdk.generate_root_verifier_asm` function). To specify the ASM file, users need to provide the
/// parent folder and filename of the ASM file.
/// To call this function:
/// 1. users need to provide `app_exe_commit`/`app_vm_commit`/`user_pvs`(user public values) as the
///    arguments. CAREFUL: `app_exe_commit`/`app_vm_commit` are in u32 and are interpreted as native
///    fields. `user_pvs` are the exact public values of that proof. Here we assume all the public
///    values are `u8`s.
/// 2. Provide the corresponding stark proof in the key-value store in OpenVM streams. The key
///    should be the concatenation of the filename, `app_exe_commit`, `app_vm_commit`, and
///    `user_pvs` in little-endian bytes. Users can use
///    `openvm::host::compute_hint_key_for_verify_openvm_stark` to compute the hint key.
#[macro_export]
macro_rules! define_verify_openvm_stark {
    ($fn_name: ident, $asm_folder: expr, $asm_filename: literal) => {
        pub fn $fn_name(app_exe_commit: &[u32; 8], app_vm_commit: &[u32; 8], user_pvs: &[u8]) {
            // The memory location for the start of the heap.
            const HEAP_START_ADDRESS: u32 = 1 << 24;
            const FIELDS_PER_U32: u32 = 4;
            const FILENAME: &str = $asm_filename;
            // Construct the hint key
            let hint_key: alloc::vec::Vec<u8> = FILENAME
                .as_bytes()
                .iter()
                .cloned()
                .chain(app_exe_commit.iter().flat_map(|x| x.to_le_bytes()))
                .chain(app_vm_commit.iter().flat_map(|x| x.to_le_bytes()))
                .chain(user_pvs.iter().cloned())
                .collect();
            openvm::io::hint_load_by_key(&hint_key);
            // Store the expected public values into the beginning of the native heap.
            let mut native_addr = HEAP_START_ADDRESS;
            for &x in app_exe_commit {
                openvm::io::store_u32_to_native(native_addr, x);
                native_addr += FIELDS_PER_U32;
            }
            for &x in app_vm_commit {
                openvm::io::store_u32_to_native(native_addr, x);
                native_addr += FIELDS_PER_U32;
            }
            for &x in user_pvs {
                openvm::io::store_u32_to_native(native_addr, x as u32);
                native_addr += FIELDS_PER_U32;
            }
            // Assumption: the asm file should be generated by SDK. The code block should:
            // 1. Increase the heap pointer in order to avoid overwriting expected public values.
            // 2. Hint a stark proof from the input stream
            // 3. Verify the proof
            // 4. Compare the public values with the expected ones. Panic if not equal.
            unsafe { core::arch::asm!(include_str!(concat!($asm_folder, "/", $asm_filename)),) }
        }
    };
}
