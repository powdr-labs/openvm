use std::result::Result;

use num_bigint::BigUint;
use openvm_circuit::{
    arch::{
        AirInventory, ChipInventoryError, InitFileGenerator, MatrixRecordArena, SystemConfig,
        VmBuilder, VmChipComplex, VmProverExtension,
    },
    system::{SystemChipInventory, SystemCpuBuilder, SystemExecutor},
};
use openvm_circuit_derive::VmConfig;
use openvm_rv32im_circuit::{
    Rv32I, Rv32IExecutor, Rv32ImCpuProverExt, Rv32Io, Rv32IoExecutor, Rv32M, Rv32MExecutor,
};
use openvm_stark_backend::{
    config::{StarkGenericConfig, Val},
    p3_field::PrimeField32,
    prover::cpu::{CpuBackend, CpuDevice},
};
use openvm_stark_sdk::engine::StarkEngine;
use serde::{Deserialize, Serialize};

mod modular;
pub use modular::*;
mod fp2;
pub use fp2::*;

cfg_if::cfg_if! {
    if #[cfg(feature = "cuda")] {
        mod cuda;
        mod hybrid;
        pub use cuda::*;
        pub use hybrid::*;
        pub use {
            AlgebraHybridProverExt as AlgebraProverExt,
            Rv32ModularHybridBuilder as Rv32ModularBuilder,
            Rv32ModularWithFp2HybridBuilder as Rv32ModularWithFp2Builder,
        };
    } else {
        pub use self::{
            AlgebraCpuProverExt as AlgebraProverExt,
            Rv32ModularCpuBuilder as Rv32ModularBuilder,
            Rv32ModularWithFp2CpuBuilder as Rv32ModularWithFp2Builder,
        };
    }
}

pub struct AlgebraCpuProverExt;

#[derive(Clone, Debug, VmConfig, Serialize, Deserialize)]
pub struct Rv32ModularConfig {
    #[config(executor = "SystemExecutor<F>")]
    pub system: SystemConfig,
    #[extension]
    pub base: Rv32I,
    #[extension]
    pub mul: Rv32M,
    #[extension]
    pub io: Rv32Io,
    #[extension]
    pub modular: ModularExtension,
}

impl InitFileGenerator for Rv32ModularConfig {
    fn generate_init_file_contents(&self) -> Option<String> {
        Some(format!(
            "// This file is automatically generated by cargo openvm. Do not rename or edit.\n{}\n",
            self.modular.generate_moduli_init()
        ))
    }
}

impl Rv32ModularConfig {
    pub fn new(moduli: Vec<BigUint>) -> Self {
        Self {
            system: SystemConfig::default(),
            base: Default::default(),
            mul: Default::default(),
            io: Default::default(),
            modular: ModularExtension::new(moduli),
        }
    }
}

#[derive(Clone, Debug, VmConfig, Serialize, Deserialize)]
pub struct Rv32ModularWithFp2Config {
    #[config(generics = true)]
    pub modular: Rv32ModularConfig,
    #[extension]
    pub fp2: Fp2Extension,
}

impl Rv32ModularWithFp2Config {
    pub fn new(moduli_with_names: Vec<(String, BigUint)>) -> Self {
        let moduli = moduli_with_names
            .iter()
            .map(|(_, modulus)| modulus.clone())
            .collect();
        Self {
            modular: Rv32ModularConfig::new(moduli),
            fp2: Fp2Extension::new(moduli_with_names),
        }
    }
}

impl InitFileGenerator for Rv32ModularWithFp2Config {
    fn generate_init_file_contents(&self) -> Option<String> {
        Some(format!(
            "// This file is automatically generated by cargo openvm. Do not rename or edit.\n{}\n{}\n",
            self.modular.modular.generate_moduli_init(),
            self.fp2.generate_complex_init(&self.modular.modular)
        ))
    }
}

#[derive(Clone)]
pub struct Rv32ModularCpuBuilder;

impl<E, SC> VmBuilder<E> for Rv32ModularCpuBuilder
where
    SC: StarkGenericConfig,
    E: StarkEngine<SC = SC, PB = CpuBackend<SC>, PD = CpuDevice<SC>>,
    Val<SC>: PrimeField32,
{
    type VmConfig = Rv32ModularConfig;
    type SystemChipInventory = SystemChipInventory<SC>;
    type RecordArena = MatrixRecordArena<Val<SC>>;

    fn create_chip_complex(
        &self,
        config: &Rv32ModularConfig,
        circuit: AirInventory<SC>,
    ) -> Result<
        VmChipComplex<SC, Self::RecordArena, E::PB, Self::SystemChipInventory>,
        ChipInventoryError,
    > {
        let mut chip_complex =
            VmBuilder::<E>::create_chip_complex(&SystemCpuBuilder, &config.system, circuit)?;
        let inventory = &mut chip_complex.inventory;
        VmProverExtension::<E, _, _>::extend_prover(&Rv32ImCpuProverExt, &config.base, inventory)?;
        VmProverExtension::<E, _, _>::extend_prover(&Rv32ImCpuProverExt, &config.mul, inventory)?;
        VmProverExtension::<E, _, _>::extend_prover(&Rv32ImCpuProverExt, &config.io, inventory)?;
        VmProverExtension::<E, _, _>::extend_prover(
            &AlgebraCpuProverExt,
            &config.modular,
            inventory,
        )?;
        Ok(chip_complex)
    }
}

#[derive(Clone)]
pub struct Rv32ModularWithFp2CpuBuilder;

impl<E, SC> VmBuilder<E> for Rv32ModularWithFp2CpuBuilder
where
    SC: StarkGenericConfig,
    E: StarkEngine<SC = SC, PB = CpuBackend<SC>, PD = CpuDevice<SC>>,
    Val<SC>: PrimeField32,
{
    type VmConfig = Rv32ModularWithFp2Config;
    type SystemChipInventory = SystemChipInventory<SC>;
    type RecordArena = MatrixRecordArena<Val<SC>>;

    fn create_chip_complex(
        &self,
        config: &Rv32ModularWithFp2Config,
        circuit: AirInventory<SC>,
    ) -> Result<
        VmChipComplex<SC, Self::RecordArena, E::PB, Self::SystemChipInventory>,
        ChipInventoryError,
    > {
        let mut chip_complex =
            VmBuilder::<E>::create_chip_complex(&Rv32ModularCpuBuilder, &config.modular, circuit)?;
        let inventory = &mut chip_complex.inventory;
        VmProverExtension::<E, _, _>::extend_prover(&AlgebraCpuProverExt, &config.fp2, inventory)?;
        Ok(chip_complex)
    }
}
